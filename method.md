1. 基于正则文法的算法

   将正则文法编译成确定有限状态自动机，然后以二元组$(pos, state)$为节点建立转移图，求最短路。

   - `(pos, state) -> (pos+1, state)`：对应插入一个字符，代价为1
   - `(pos, state) -> (pos+1, next(state, ch))`: 如果ch为输入的第pos个字符，代价为0，否则代价为1；
   - `(pos, state) -> (pos, next(state, ch))`：对应删除一个字符，代价为0

   求起始状态`(0, start)`到终止状态`(n, end)`的最短路就是最小的编辑距离。

   时间复杂度$O(|A|n)$，$n$为输入串$S$的长度。

2. 基于上下文无关文法的算法

   使用CYK算法分析并纠错。在动态规划时记录最短编辑距离。

   对于非终结符$A$，令$f_A(l, r)$为将输入串$S[l:r]$变为非终结符$A$的最小编辑代价，然后使用区间动态规划转移即可：
   
   - 对于$A \rightarrow BC$，则$f_A(l, r) = \min_k\{f_B(l, k) + f_B(k, r)\}$。
   
   时间复杂度$O(|G|n^3)$

两种方法对比：

- 法1的时间复杂度关于$n$成正比，法2关于$n^3$成正比；
- 法1的自动机$|A|$大小通常要比法2的语法大小$|G|$大很多：
  - $|A|$可能会关于支持的命令种类呈指数级增长；$|G|$则能严格保证线性增长。
  - 例如，不同命令都有”文件名“参数，法1的每个命令都会生成描述该文件名的正则表达式对应的状态，但法2则可共用一个非终结符，表示“文件名”；
- 法1可以使用A*算法优化；法2也可考虑使用剪枝优化：比如只考虑代价不超过某个阈值的状态，该优化实现起来稍微麻烦一些。
- 法2的扩展性较好：例如，某些非终结符可以采用其他方法计算最小代价。典型的例子是文件名，可以另外定义一个Oracle，计算某个子串到系统中的某个文件名的最小编辑代价；这样可以和系统环境的信息结合起来。